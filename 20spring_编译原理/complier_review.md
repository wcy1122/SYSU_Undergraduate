## 词法分析
正则表达式
有限自动机：识别正则表达式所描述的语言（如：判断词是否是浮点数）
- 非确定性有限自动机（nfa），构造，识别
- 确定性有限自动机（dfa是特殊的nfa，约束：无ε转移，转移后的节点唯一确定）
正则表达式（递归定义） -> nfa -> dfa -> dfa的最小化
\* 正则文法，等价性

### 考点
构造RE，RE转NFA，NFA转DFA，DFA最小化

#### 构造RE
$L^{*}$，L出现0次或多次
$L^{+}$，L出现1次或多次
$L^{x}$，L出现x次
$L?$，L出现0次或1次

#### 构造NFA
- R1*
- R1|R2
- R1R2

#### NFA 转 DFA
约束：无ε转移，转移后的节点唯一确定
ε闭包：一个点经过若干次ε操作能够到达的点的集合
转换方法：
1. 以S为起点，构造ε闭包
2. 以当前ε闭包为起点，枚举字母找到接上当前字母能到达的所有节点（真正能到的，不接ε）
3. 对于每组节点构造ε闭包，然后重复2-3的操作直到没有新的闭包出现
4. 给闭包重命名

NFA / DFA / RE / 正则文法 表述能力是一样的，DFA，NFA都能找到对应的RE r

#### DFA最小化
1.	将所有状态划分为两个子集，终结态集和非终结态集
2.	对于每个子集，如果输入某个符号后得到的后继转移状态不在同一个子集，则根据那个不同的结果分裂该子集（如果有一些点输入某符号非法，要和走得了区分以下）
3.	直到没有子集可以分裂，每个子集取一个元素做代表

## 语法分析

### 上下文无关文法（CFG）
终端符号，非终端符号，开始符号（第一个expr的非终端符号），产生式
0型：无限制文法
1型：上下文有关文法，a->b，|a|<=|B|
2型：上下文无关文法(CFG)：a->b，a必须是非终端符号，b可以包含终端符号也可以包含非终端符号，不能是ε
3型：正则文法(RG)：左线性文法：A->Bw / A->w，右线性文法：A->wB / A->w，AB为单个非终端符号，w为单个终端符号[CFG也存在这种说法]
cmp with CFG && RG：RG不支持递归定义，A必须为新定义的，B必须为已定义的，这也导致了CFG定义语言的能力>RG | RE, NFA, DFA 之流

### 文法的二义性与消除
推导：代入一个句子，初始为开始符号，根据文法规则和句子一步一步替换
最左推导：从开始符号开始，每次替换最左边第一个非终端符号
最右推导：从开始符号开始，每次替换最右边第一个非终端符号
分析树：每次推导，一个非终端节点代表的非叶子节点加上几个孩子（即->右边的东西）
文法二义性：能够生成不止一棵分析树（比如优先级不确定）
- 不一定能消除，不能写程序判定
消除：规定优先级（\* > +），优先级弱先写
> E -> E+E | E\*E | (E) | id

to
> E -> E+T | T
> T -> T\*F | F
> F -> (E) | id

两大类方法
- top-down，button-up

### 自顶向下

#### 消除左递归
左递归：A->Aa or generally, A->Aa1 | Aa2 | ... | Aam | b1 | b2 | ... | bn
a,b可以包含任意个任意符号（终端，非终端）
消除后
> A -> b1A' | b2A' | ... |bnA'
> A' -> a1A' | a2A' | a3A' | ... | amA' | ε

如果没有b
> A -> A'

**多步左递归**
example
> S -> Aa
> A -> Sd

隐藏左递归
> S ->Aa ->Sda

消除多步左递归
1.	将所有非终端符号A1, A2, ..., An随便排序
2.	枚举Ai，再在[1,i-1]枚举Aj
3.	对于所有$A_i->A_j \lambda$，把Aj代入Ai的产生式中
4.	现在没有多步左递归了，按照正常消除左递归的方法搞就行了

#### 递归下降法
开始符号开始推导出要分析的串
每一步如果有多个合适的产生式，要依次枚举回溯

#### 预测分析法

##### 消除左因子（Left Factoring）
对于一个产生式
> S -> xyza | xyzb | c

to
> S -> xyzS' | c
> S' -> a | b

没用，如果有两个产生式，第一个都是非终端符号，则gg

##### First函数
定义：X产生式的所有可能的第一个终端符号
根据定义随便求一求就好了
关于ε：
1.	如果X -> ε，则ε加入First(X)中
2.	对于X -> X1 X2 X3 ，1~Xi-1 中都包含ε，则First(Xi)加入First(X)，包括ε

##### Follow函数
定义：X产生式后所有可能的第一个终端符号
三条规则
1.	$ 放入 Follow(S)
2.	if A -> aBC, then 把 { First(C)-ε } 加入 Follow(B)
3.	if A -> aB，或A -> aBC且First(C)包含ε（即B可能是最后一个）, then 把 Follow(A) 加入 Follow(B)，反过来不一定

##### 构造预测表
对于每个A->a
1.	根据First(a)构造，每个元素的格子填对应的产生式
2.	如果First(a)里面有ε，对于Follow(A)中的所有终结符b，把A->a加入到M[A,b]表格中
3.	如果First(a)里面有ε，Follow(A)里面有$，把A->a加入到M[A,$]表格中
4.	如果M[A,a]是空的，那就报错

#### LL(1)文法
预测表不冲突，具体来说，对于任意 A->a|b
- First(a) 和 First(b) 不相交
- First(a)包含ε，则Follow(A)和First(b)不相交，ab交换亦然

#### 预测分析法的实现
##### 递归法
lookahead 表示当前Scan到的下一个字符
根据预测分析表定义搞即可

##### 基于 栈和分析表 的方法
基于最左推导
- 初始栈里面放$S$$
- 假设当前栈顶是X，当前输入符号是a
- 如果X==$，结束
- 如果X->a，X出栈
- 如果X是终止符号，或M[x, a]是error()，报错
- 如果M[x, a]=X->Y1 Y2 ... Yk，把X退栈，Y1 Y2 ... Yk 进栈，其中Y1放到栈顶


### 自底向上
移进规约（shift-reduce）法
移进 (shift)：将输入的第一个表达式入栈
规约 (reduce)：把产生式左边换成产生式右边
本质就是最右推导（上面那个基于栈和分析表的方法）的逆过程

#### 句柄（Handle）
对于所有最右推导过程中产生的串（右句型），都有Handle，Handle是要用来Reduce的字符，句柄存在就去Reduce，句柄不存在就去Shift
简单易懂版：最右推导最后一个被换掉的产生式的右边

#### LR(k)分析
从左往右扫描，使用最右推导，向前看k步
不同的LR(k)分析构造的Action（终端去哪，sx即移进到x，rx即归约到x）表和GOTO（非终端符号，归约之后去哪）表不一样
最简单，SLR分析

#### SLR

**LR(0)term：** 产生式插空加 · ，长度为L的有L+1个，对于S->ε，只产生一个LR(0)项S-> · 
**扩充文法：** 增加一项S'->S
**闭包：** 一些产生式的闭包，把 · 后面所有的非终结符号为起点的产生式都加进去（持续进行，直到没有为止）
****
**GOTO：** 当前状态输入终结符x后shift到哪或用什么产生式reduce
**Action：** 当前状态输入终结符E后会到shift哪
具体流程：
1.	构造扩充文法
2.	从 S'->·S 开始，一路根据闭包构造项集（采用LR(0) term）
3.	给项集编号，根据连边构造GOTO集合中shift部分和Action集合
4.	对于项集中 S->ABCD· 这种，构造GOTO集合的Reduce部分（把Follow(S)中的所有字符对应的表都填上rx）（除了 S'->S·，这个接(acc））
非SLR文法：SLR出现冲突（比如又能shift又能reduce）

#### LR(1)
**LR(1)项：** [A -> $\alpha$ · $\beta$, a]，前者是项的core，a可以是任意个终端符号或$
这个a指向前看符号，的意思是A完之后下一个字符是谁，所以对应的是生成A的那个产生式A后一个符号的First/非终结符，如果A后没有了就把那个产生式的 向前看符号 抄过来。向前看符号 可以是多个，比如 a/b/c。如果是$表示A之后就没有了
**规约：** [如果出现A->XXX· a/b/+]，则该状态后如果接 a/b/+ ，按这条规则规约
只有 [S’->S· $] 接 acc
和LR(0)的本质区别：状态多了一个向前看符号，区分了一些点

#### LALR
LR(1)的问题：状态数太多，很多状态除了lookahead之外一模一样
把 **除了lookahead之外一模一样** 的状态们分组合并
**结论：** 通过merge不会产生新的 **shift-reduce** 冲突，可能产生新的S/R（不知道规约到哪，多个都可以）冲突

#### 冲突消除
二义性文法，冲突不可避免（比如 SR冲突）
引入认为规则解决

#### 可行前缀（Viable Prefixes）
最右推导句柄左边所有字符串前缀（包括句柄，不能跨越句柄），也包括空？

向前看符号，td和bu都有
- td的向前看：和产生式能推导出来的第一个终端符号匹配
- bu的向前看：和句柄之后的第一个终端符号匹配，类似Follow

## 语法指导翻译（Syntax-Directed Translation）
应用：包括语义分析，中间代码生成
基于分析树，在分析树上对每个节点做语义标记
基本思想：每个产生式要关联语义规则，对文法符号引入属性（数据类型）进行计算

### 语法指导定义
有一个产生式集，给每个产生式关联一些语义规则
比如 L->E to L.val=E.val
具体步骤
1.	给文法符号增加属性
2.	对于每个产生式定义语法规则
3.	根据跟系数画依赖图
4.	通过对依赖图的拓扑排序（L to R）确定属性计算顺序
5.	根据属性计算顺序运行语法规则

#### 继承属性，综合属性
- 继承属性（Inherited Attribute）：一个节点的继承属性值由其父亲或兄长（它左边的右端符号）节点决定 [L to R, U to D]
- 综合属性（Synthesized Attribute）：一个节点的综合属性的值由其子节点的属性值决定 [D to U]
区分：由孩子决定的是综合属性，其余全是继承属性（包括直接赋常数）

不用画语法树，增加属性约束
#### S属性定义
所有文法符号的属性都是综合属性，适合LR分析（自底向上）
具体做法，结合移进规约法，构造符号栈从下往上跑，规约的相应位置要计算值

#### L属性定义
属性可以是综合属性，也可以是继承属性，运算顺序类似递归向下预测分析
继承属性不能依赖于其父亲的综合属性，继承属性要在Reduce之前完成计算
属性计算的顺序等同于分析树的DFS序，枚举每个ch的时候计算对应的继承属性，枚举结束后根据ch计算当前节点的综合属性

### 翻译模式
语法指导定义给出语义规则，没有指定计算顺序；翻译模式隐含了计算顺序
本质：分析树上加一些节点，表示语义动作
语义动作可以在产生式的任意位置，不一定都是最后

### L属性定义 to 翻译模式 的规则
- **计算**A的 **继承属性**的规则要在A**符号之前**
- 一个语义动作不能引用符号右侧的综合属性
- 综合属性必须在其引用的所有属性(继承/综合)计算完后计算

#### 使用递归下降法和L属性定义
写LL(1)文法 -> 写L属性定义 -> 转换翻译模 -> 消除左递归（会产生一些继承属性） -> 递归下降分析
本质：继承属性 == 形参，综合属性 == 返回值

#### 如果使用LR分析？
S属性简单，L属性怎么办（分析栈里面不存L属性）?
跟踪继承属性的值，如果继承属性是综合属性的copy，直接记录位置
如果不是copy，引入 **marker** 标记符，把获取继承值的过程作为语义动作
把所有动作嵌入到产生式的最右侧
**marker：** 占位符，M->ε，并后缀语义动作，用于替换嵌入的语义动作

## 中间代码生成

### 三地址码
**取址方式：** Name / 常数 / 临时变量
**指令格式：**
x = y op z;  x = op y;  x = y;
goto L;  if x goto L;  iffalse x goto L;  if x op y goto L;
函数调用 y=p(x1, x2,...,xn)
param x1
param x2
...
param xn
y = call p, n
return y // 返回值
**实现方式：** 
四元组 (op arg1 arg2 result) 适合优化
三元组 (op arg1 arg2) result用行号代替，不适合优化（要大改行号）
间接三元组 (op arg1 arg2) 增加索引表，方便交换？
静态单赋值形式，同名加下表

类型定义声明，变量声明，空间定义
数组元素的引用，计算offset

## 运行环境

### 存储类型
[Low] 代码区，静态变量区（Static Area），堆区（new/delete malloc/free），栈区（局部变量）[High]
代码区的地址是静态的，运行时不变，不能修改
寄存器：通用寄存器（用于计算），特殊寄存器（如PC, sp, fp, ap）

### 栈和活动记录（Activation Record）
调用序列（传参数，保护调用环境[局部变量，返回地址(pc)]，调用调用环境）
返回序列（传参数，释放空间，恢复调用环境）
运行环境
- 静态运行环境：固定地址，无递归调用，无动态内存
- 基于栈无局部过程：维护当前活动记录指针(fp) 栈指针(sp)，略
- 基于栈有局部过程：
control link，指向**caller**的活动记录
access link，指向**定义**该局部过程的活动记录

### 运行时环境
垃圾（不再引用的object）回收，主要针对heap
问题：内存碎片化，暂停正常执行的程序，局部性

- 引用计数，A引用B则连单向边，回收reference count==0的内存，问题：环路
- mark-and-sweep，从root找到所有引用的object，剩余的回收，周期性运行（碎片化，实时性）
- mark-and-compact，先从root出发打标记，后将所有有标记的扔到heap的一侧，避免碎片化
- copy-collector，对于heap的前半部分从root出发打标记，可达的扔到后半部分，比上面快一点，空间只用一半
- Generational Garbage Collection，根据垃圾的存在时间分代（e.g. young and old）

## 代码生成
- 指令选择，选择合适的指令执行三地址码
- 寄存器分配于使用，选择一些变量放在寄存器里，选择合适的寄存器给变量赋值
- 指令排序

### Basic Block && Flow Graph

Basic Block：一些三地址指令的集合
若干个Basic Block连边构成Flow Graph
Leader：每个 Basic Block的第一条指令
根据Leader划分 Basic Block

#### 怎么找到Leader
1.	第一条三地址指令
2.	每条 jump或goto 指令的目标
3.	jump 或 goto 指令的后一条指令

## 代码优化
时空复杂度，目标代码运行效率
### 优化级别
源代码级(人工) / 中间代码优化(自动) / 目标代码优化(机器相关)

### 优化范围
滑动窗口(Peephole) / 局部优化(对于一个basic block) / 循环优化 / 全局优化
局部优化：公共子表达式  常量计算  消除重复计算
循环不变量计算
循环变量优化（t1=4\*i, i=i+1 to t1=t1+4）

### 局部优化


### 控制流语句
Loop：单入口（在这个Loop中，入边对应的出边至少有一个不在Loop内），强连接
Dominator：m DOM n表示m支配n，D(n) = {m | m DOM n}，支配n的集合
entry是Loop中所有node的Dominator，满足自反，传递，反对称
这货就是支配树的支配点（必经点）

### 控制流分析与循环优化
回边：b DOM a，a->b如果在图中则为回边（a可以=b）
Nature Loop：对于一条回边a->b，不通过b能到达a的所有节点+b
构造，把b丢栈里，从a开始逆向网上找，找边入栈


